<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Strapi 5 installation, export, import, and transfer guide for Windows. Environment variables, upload plugin config, and data migration.">
  <title>Strapi 5 – Install (Windows), Export, Import, Transfer &amp; .env</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; max-width: 1200px; margin: 0 auto; padding: 2rem; color: #333; }
    h1 { font-size: 2.5em; color: #1a1a1a; border-bottom: 3px solid #0066cc; padding-bottom: 0.5rem; }
    h2 { font-size: 1.8em; color: #2d2d2d; margin-top: 2rem; border-left: 4px solid #0066cc; padding-left: 15px; }
    h3 { font-size: 1.4em; color: #333; margin-top: 1.5rem; }
    h4 { font-size: 1.2em; color: #555; }
    ul, ol { margin: 0.5rem 0; }
    li { margin: 0.25rem 0; }
    code { background-color: #e8f4f8 !important; color: #0d3b66 !important; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; font-size: 0.9em; border: 1px solid #b8d4e3; }
    pre, pre code,
    .command-wrap pre, .command-wrap pre code,
    ol pre, ol pre code, ul pre, ul pre code, li pre, li pre code, div pre, div pre code {
      background-color: #e8f4f8 !important; color: #0d3b66 !important; border-color: #b8d4e3;
    }
    pre { padding: 1rem; overflow-x: auto; white-space: pre-wrap; border-radius: 4px; margin: 15px 0; position: relative; border: 1px solid #b8d4e3; }
    pre code { background-color: transparent !important; color: #0d3b66 !important; padding: 0; }
    .command-wrap { position: relative; margin: 15px 0; }
    .command-wrap .copy-btn {
      position: absolute; top: 8px; right: 8px; z-index: 1;
      background-color: #0066cc; color: white; border: none; padding: 6px 12px; border-radius: 4px;
      cursor: pointer; font-size: 0.85em; font-weight: bold; transition: all 0.3s ease;
    }
    .command-wrap .copy-btn:hover { background-color: #0052a3; }
    .command-wrap .copy-btn.copied { background-color: #28a745; }
    a { color: #0066cc; }
    .note, .info { background: #d1ecf1; border-left: 4px solid #0c5460; padding: 0.75rem 1rem; margin: 1rem 0; }
    .warn { background: #fff3cd; border-left: 4px solid #ffc107; padding: 0.75rem 1rem; margin: 1rem 0; }
    .caution { background: #f8d7da; border-left: 4px solid #dc3545; padding: 0.75rem 1rem; margin: 1rem 0; }
    .note code, .note .code-highlight, .info code, .info .code-highlight,
    .warn code, .warn .code-highlight, .caution code, .caution .code-highlight {
      background-color: #e8f4f8; color: #0d3b66; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; border: 1px solid #b8d4e3;
    }
    table { border-collapse: collapse; width: 100%; margin: 15px 0; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
    th { background: linear-gradient(135deg, #0066cc 0%, #0052a3 100%); color: white; font-weight: bold; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.5px; }
    tr:nth-child(even) { background-color: #f8f9fa; }
    tr:hover { background-color: #e3f2fd; transition: background-color 0.2s ease; }
    td code { background-color: #e8f4f8; color: #0d3b66; padding: 3px 8px; border-radius: 3px; font-family: 'Courier New', monospace; border: 1px solid #b8d4e3; }
    .section-intro { background: linear-gradient(135deg, #e8f4f8 0%, #d1e7f0 100%); border-left: 4px solid #0066cc; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 8px rgba(0, 102, 204, 0.1); }
    .section-intro code { background-color: #e8f4f8; color: #0d3b66; padding: 3px 8px; border-radius: 3px; border: 1px solid #b8d4e3; }
    @media (max-width: 768px) { body { padding: 10px; } }
  </style>
</head>
<body>
  <h1>Strapi 5 – Install (Windows), Export, Import &amp; Transfer</h1>
  <div class="section-intro">
    <p>This document covers:</p>
    <ul>
    <li><strong>Installing Strapi 5 on Windows</strong> – prerequisites and setup.</li>
    <li><strong>Configuring the upload (image) plugin</strong> – same setup as this project (local provider, security, body limits).</li>
    <li><strong>Environment variables (.env)</strong> – which properties you need (no credentials shown).</li>
    <li><strong>API tokens and encryption key</strong> – whether you can reuse tokens or the same encryption key across installations.</li>
    <li><strong>Transfer</strong> – stream data from one running Strapi instance to another (same schema).</li>
    <li><strong>Export / Import</strong> – export to a file, copy the file, then import on the destination.</li>
    <li><strong>Strapi Cloud</strong> – deploy and optionally import or transfer data into Cloud.</li>
    </ul>
  </div>

  <nav class="section-intro toc" aria-label="Table of contents">
    <h3 id="toc">Table of Contents</h3>
    <ol>
      <li><a href="#install">Installing Strapi 5 on Windows</a></li>
      <li><a href="#upload">Configuring the upload plugin</a></li>
      <li><a href="#env">Environment variables</a></li>
      <li><a href="#tokens">API tokens and encryption key</a></li>
      <li><a href="#prereq">Prerequisites</a></li>
      <li><a href="#transfer">Option A – Transfer</a></li>
      <li><a href="#export-import">Option B – Export then Import</a></li>
      <li><a href="#included">What is included / excluded</a></li>
      <li><a href="#cloud">Strapi Cloud</a></li>
      <li><a href="#cloud-troubleshoot">Strapi Cloud – Post-transfer troubleshooting</a></li>
      <li><a href="#quickref">Quick reference</a></li>
      <li><a href="#docs">Official documentation</a></li>
      <li><a href="#rest-push-summary">REST push – summary and helper scripts</a></li>
    </ol>
  </nav>

  <div class="caution">
    <strong>Admin users and API tokens are never transferred or exported.</strong> You must recreate admin users (and API tokens) on the destination after any migration. The <code class="code-highlight">createdBy</code> and <code class="code-highlight">updatedBy</code> fields in content will be empty after import/transfer.
  </div>

  <h2 id="install">1. Installing Strapi 5 on Windows</h2>
  <ol>
    <li><strong>Node.js</strong> – Install Node.js LTS (e.g. 20.x or 22.x) from <a href="https://nodejs.org" target="_blank" rel="noopener">nodejs.org</a>. Use the Windows installer. Restart the terminal (or IDE) after installation.</li>
    <li><strong>npm</strong> – Comes with Node.js. Verify: <code>node -v</code> and <code>npm -v</code>.</li>
    <li><strong>Create a new project</strong> (or clone this repo):
      <pre><code>npx create-strapi-app@latest my-project --quickstart</code></pre>
      <code>--quickstart</code> uses SQLite and opens the admin in the browser. For a custom database, omit <code>--quickstart</code> and follow the prompts.
    </li>
    <li><strong>Or use this project</strong> – Clone the repo, then in the project root:
      <pre><code>npm install</code></pre>
      Copy <code>.env.example</code> to <code>.env</code> (Windows: <code>copy .env.example .env</code>; macOS/Linux: <code>cp .env.example .env</code>). Edit <code>.env</code> and set the required variables (see §3). Do not commit <code>.env</code>.
    </li>
    <li><strong>Build and run</strong>:
      <pre><code>npm run build
npm run develop</code></pre>
      For production: <code>npm run start</code>. Admin is usually at <code>http://localhost:1337/admin</code>.
    </li>
  </ol>
  <p>If you see permission or path-length issues on Windows, run the terminal as Administrator or enable long paths (e.g. <code>git config core.longpaths true</code> in the repo).</p>

  <h2 id="upload">2. Configuring the upload (image) plugin</h2>
  <p>This project configures the built-in upload plugin so dashboard image uploads work and do not hang (Strapi 5 requires an explicit upload security configuration). Apply the same on the other machine (or in Strapi Cloud if you deploy this code).</p>
  <h3>2.1 Upload plugin – <code>config/plugins.js</code></h3>
  <p>Create or merge this in <code>config/plugins.js</code>:</p>
  <pre><code>module.exports = ({ env }) => ({
  upload: {
    config: {
      provider: 'local',
      sizeLimit: 250 * 1024 * 1024, // 250 MB (must match body middleware below)
      security: {
        allowedTypes: ['image/*', 'video/*', 'audio/*', 'application/pdf', 'application/*'],
        deniedTypes: ['application/x-sh', 'application/x-executable', 'application/x-dosexec'],
      },
    },
  },
});</code></pre>
  <p>Without <code>security</code>, Strapi 5 can log &quot;No upload security configuration found&quot; and dashboard uploads may hang or fail.</p>
  <h3>2.2 Body middleware – <code>config/middlewares.js</code></h3>
  <p>Ensure the <code>strapi::body</code> middleware allows large multipart uploads (e.g. 250 MB). Replace or add this entry in the <code>config/middlewares.js</code> array:</p>
  <pre><code>{
  name: 'strapi::body',
  config: {
    formLimit: '256mb',
    jsonLimit: '256mb',
    textLimit: '256mb',
    formidable: {
      maxFileSize: 250 * 1024 * 1024, // 250 MB — multipart uploads (Media Library)
    },
  },
},</code></pre>
  <p>Keep other middlewares (e.g. <code>strapi::logger</code>, <code>strapi::security</code>, <code>strapi::cors</code>, etc.) as in the default or this project. Restart Strapi after changing <code>plugins.js</code> or <code>middlewares.js</code>.</p>

  <h2 id="env">3. Environment variables (.env)</h2>
  <p>Only <strong>property names</strong> are listed below. Set values in <code>.env</code>; never commit real credentials. Use <code>.env.example</code> as a template and copy it to <code>.env</code> then fill in.</p>
  <table>
    <thead>
      <tr><th>Property</th><th>Required</th><th>Purpose</th></tr>
    </thead>
    <tbody>
      <tr><td><code>HOST</code></td><td>Optional</td><td>Server bind address (default <code>0.0.0.0</code>).</td></tr>
      <tr><td><code>PORT</code></td><td>Optional</td><td>Server port (default <code>1337</code>).</td></tr>
      <tr><td><code>APP_KEYS</code></td><td>Yes</td><td>Comma-separated list of at least one key (e.g. <code>key1,key2</code>). Used for session signing.</td></tr>
      <tr><td><code>API_TOKEN_SALT</code></td><td>Yes</td><td>Salt for hashing API tokens (admin-created tokens).</td></tr>
      <tr><td><code>ENCRYPTION_KEY</code></td><td>Yes</td><td>Used by admin panel (e.g. encrypting transfer tokens).</td></tr>
      <tr><td><code>ADMIN_JWT_SECRET</code></td><td>Yes</td><td>Secret for admin JWT (admin login).</td></tr>
      <tr><td><code>TRANSFER_TOKEN_SALT</code></td><td>Yes (if using transfer)</td><td>Salt for transfer tokens (data transfer feature).</td></tr>
      <tr><td><code>JWT_SECRET</code></td><td>Yes (if using Users &amp; Permissions)</td><td>Secret for API JWT (front-end / plugin users).</td></tr>
      <tr><td><code>DATABASE_CLIENT</code></td><td>Optional</td><td><code>sqlite</code>, <code>postgres</code>, or <code>mysql</code>. Default <code>sqlite</code>.</td></tr>
      <tr><td><code>DATABASE_FILENAME</code></td><td>SQLite</td><td>Path to SQLite file (e.g. <code>.tmp/data.db</code>).</td></tr>
      <tr><td><code>DATABASE_URL</code></td><td>Postgres</td><td>Full connection string for PostgreSQL.</td></tr>
      <tr><td><code>DATABASE_HOST</code>, <code>DATABASE_PORT</code>, <code>DATABASE_NAME</code>, <code>DATABASE_USERNAME</code>, <code>DATABASE_PASSWORD</code></td><td>MySQL/Postgres</td><td>Connection details when not using <code>DATABASE_URL</code>.</td></tr>
      <tr><td><code>DATABASE_SSL</code>, <code>DATABASE_SSL_*</code></td><td>Optional</td><td>SSL options for database (e.g. <code>DATABASE_SSL_KEY</code>, <code>DATABASE_SSL_CERT</code>).</td></tr>
      <tr><td><code>DATABASE_SCHEMA</code></td><td>Optional (Postgres)</td><td>Schema name (default <code>public</code>).</td></tr>
      <tr><td><code>STRAPI_DATA_IMPORT_PROJECT_CLONE_DIR</code>, <code>TENANT_ID</code></td><td>Optional</td><td>Used by this project’s directory import script only; not required for a plain Strapi run.</td></tr>
      <tr><td><code>DATABASE_CONNECTION_TIMEOUT</code></td><td>Optional</td><td>Knex connection acquire timeout (ms). Default <code>60000</code>. Set <code>600000</code> (10 min) or higher in <code>.env</code> before running <code>strapi import</code> to reduce <code>KnexTimeoutError</code> risk with SQLite (see §7.3.1).</td></tr>
    </tbody>
  </table>
  <p>Summary: for a minimal run you need <code>APP_KEYS</code>, <code>API_TOKEN_SALT</code>, <code>ENCRYPTION_KEY</code>, <code>ADMIN_JWT_SECRET</code>, and <code>JWT_SECRET</code> (if using API users). For transfer, add <code>TRANSFER_TOKEN_SALT</code>. For Postgres, set <code>DATABASE_CLIENT=postgres</code> and <code>DATABASE_URL</code> (or individual <code>DATABASE_*</code>). For SQLite, default <code>DATABASE_FILENAME</code> is usually enough.</p>

  <h3>3.1 API token you copy (View/Copy in admin) – where does it go?</h3>
  <p>The token you copy from <strong>Settings → API Tokens → Create (or View)</strong> is <strong>not</strong> stored in Strapi’s <code>.env</code>. It is the value your <strong>application</strong> (e.g. frontend, mobile app, Postman) uses when calling the Strapi API (e.g. <code>Authorization: Bearer &lt;token&gt;</code>).</p>
  <ul>
    <li>Put it in your <strong>app’s</strong> <code>.env</code>, for example: <code>STRAPI_API_TOKEN=&lt;paste the token here&gt;</code>, or <code>NEXT_PUBLIC_STRAPI_API_TOKEN=…</code> if the frontend needs it.</li>
    <li>Strapi’s own <code>.env</code> has <strong>no property</strong> for that token string. The server uses <code>API_TOKEN_SALT</code> (a secret used to hash and verify tokens), not the token value itself.</li>
  </ul>

  <h3>3.2 Where to get values for .env and reusing from this project</h3>
  <p>On a <strong>new machine</strong> you can either generate new secrets or reuse values from the existing project.</p>
  <table>
    <thead>
      <tr><th>Property</th><th>Where to get it / reuse?</th></tr>
    </thead>
    <tbody>
      <tr><td><code>APP_KEYS</code></td><td>Generate new, or copy from this project. Need at least one key; often two comma-separated: <code>key1,key2</code>.</td></tr>
      <tr><td><code>API_TOKEN_SALT</code></td><td>Generate new, or copy from this project.</td></tr>
      <tr><td><code>ENCRYPTION_KEY</code></td><td>Generate new, or copy from this project.</td></tr>
      <tr><td><code>ADMIN_JWT_SECRET</code></td><td>Generate new, or copy from this project.</td></tr>
      <tr><td><code>JWT_SECRET</code></td><td>Generate new, or copy from this project (only if you use Users &amp; Permissions API).</td></tr>
      <tr><td><code>TRANSFER_TOKEN_SALT</code></td><td>Generate new, or copy from this project (only if you use Transfer).</td></tr>
      <tr><td><code>HOST</code>, <code>PORT</code></td><td>Optional; e.g. <code>0.0.0.0</code> and <code>1337</code>. Reuse or leave default.</td></tr>
      <tr><td><code>DATABASE_*</code></td><td>For SQLite: often just <code>DATABASE_FILENAME</code>. For Postgres: <code>DATABASE_CLIENT=postgres</code> and <code>DATABASE_URL</code> (or host/port/name/user/password). Reuse from this project if the new machine uses the same DB; otherwise set new values for the new DB.</td></tr>
    </tbody>
  </table>
  <p><strong>Reusing from this project:</strong> You can copy the <strong>entire</strong> <code>.env</code> from this project to the new machine. Then only adjust <code>DATABASE_*</code> if the new machine uses a different database (e.g. new Postgres URL or a different SQLite path).</p>
  <p><strong>Generating new values</strong> (if you do not reuse): run the following once per secret; for <code>APP_KEYS</code> run it twice and set <code>APP_KEYS=first,second</code>:</p>
  <pre><code>node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"</code></pre>

  <h2 id="tokens">4. API tokens and encryption key – reuse across installations?</h2>
  <ul>
    <li><strong>API tokens (admin-created) / JWT</strong> – <strong>No.</strong> Export and transfer do <strong>not</strong> include API tokens or admin users. You cannot copy the same API token from this installation and use it on another. Each installation has its own tokens (and salts). After import or transfer, create new API tokens (and admin users) on the destination. The token value you see in the admin is only shown once; it is hashed with <code>API_TOKEN_SALT</code> in the database, so even with the same DB copy, the salt on the other machine would differ unless you deliberately copy <code>API_TOKEN_SALT</code> and the DB – still not recommended; create new tokens on the new instance.</li>
    <li><strong>Export file encryption key (<code>-k</code>)</strong> – <strong>Yes.</strong> The key you use with <code>strapi export -k "…"</code> and <code>strapi import -k "…"</code> is only for encrypting/decrypting the export file. You can use the same key on the source (for export) and on the destination (for import), or any secure key you prefer on the destination. It does not affect API tokens or JWT.</li>
  </ul>

  <h2 id="prereq">5. Prerequisites (transfer and export/import)</h2>
  <ul>
    <li><strong>Identical schema</strong> – Source and destination must have the same content types (same project code or a copy). Content type names, attributes, and relations must match.</li>
    <li><strong>Strapi 5</strong> – Commands and behavior described here are for Strapi 5.</li>
    <li>For <strong>transfer</strong>: both instances must be runnable and reachable (destination first); you need a <strong>transfer token</strong> from the destination.</li>
    <li>For <strong>export/import</strong>: you need the export file and (if encrypted) the encryption key on the destination.</li>
  </ul>

  <h2 id="transfer">6. Option A – Transfer (stream to another machine)</h2>
  <p>Use this when you can run both Strapi instances and want to push or pull data over the network. Data is streamed; no intermediate file.</p>

  <h3>6.1 Enable transfer tokens (destination)</h3>
  <ol>
    <li>On the <strong>destination</strong> machine, ensure <code>config/admin.js</code> has a transfer token salt (this project uses <code>env('TRANSFER_TOKEN_SALT')</code>). Set <code>TRANSFER_TOKEN_SALT</code> in <code>.env</code> (e.g. a long random string).</li>
    <li>Build and start Strapi on the destination: <code>npm run build</code> then <code>npm run start</code> (or <code>npm run develop</code> for dev).</li>
    <li>Open the admin panel (e.g. <code>http://destination-server:1337/admin</code>), register the first admin user if needed.</li>
    <li>Go to <strong>Settings → Global settings → Transfer Tokens</strong>.</li>
    <li>Click <strong>Create new Transfer Token</strong>. Set name, optional description, duration (e.g. 30 days), and <strong>Token type</strong>:
      <ul>
        <li><strong>Push</strong> – allows transfers from another instance <em>into</em> this one (use when you run <code>strapi transfer --to &lt;this-admin-url&gt;</code> from source).</li>
        <li><strong>Pull</strong> – allows this instance to pull from another (use when you run <code>strapi transfer --from &lt;source-admin-url&gt;</code> on destination).</li>
        <li><strong>Full Access</strong> – both.</li>
      </ul>
    </li>
    <li>Save and <strong>copy the token immediately</strong> (it is shown only once). Store it securely (e.g. in a password manager or env var <code>STRAPI_TRANSFER_TOKEN</code> on the source machine).</li>
  </ol>

  <h3>6.2 Push data from source to destination</h3>
  <ol>
    <li>On the <strong>source</strong> machine, in the project root (same codebase as destination), run:
      <pre><code>npm run strapi transfer -- --to https://destination-server.example.com/admin</code></pre>
      Use the full URL to the <strong>admin</strong> (including <code>/admin</code>). For local testing: <code>http://localhost:1337/admin</code> or <code>http://127.0.0.1:1337/admin</code>.
    </li>
    <li>When prompted, paste the <strong>destination</strong> transfer token (Push or Full Access).</li>
    <li>Confirm when asked: <em>"The transfer will delete all of the remote Strapi assets and its database. Are you sure you want to proceed?"</em></li>
  </ol>
  <p>To avoid prompts (e.g. in scripts):</p>
  <pre><code>npm run strapi transfer -- --to https://destination-server.example.com/admin --to-token YOUR_TRANSFER_TOKEN --force</code></pre>

  <h3>6.3 Pull data from source into destination</h3>
  <p>Instead of running the command on the source, run it on the <strong>destination</strong> and pull from the source:</p>
  <ol>
    <li>Start the <strong>source</strong> Strapi server and ensure it is reachable from the destination (URL and firewall).</li>
    <li>On the destination machine, in the project root:
      <pre><code>npm run strapi transfer -- --from https://source-server.example.com/admin</code></pre>
    </li>
    <li>When prompted, paste the <strong>source</strong> transfer token (Pull or Full Access).</li>
    <li>Confirm the warning (local database and assets will be replaced).</li>
  </ol>

  <div class="warn">
    <strong>Limitations:</strong> If the destination uses SQLite, other DB connections are blocked during transfer. If you use WebSockets or Socket.io, temporarily disable them or use a different port/route, or transfer may fail.
  </div>

  <h2 id="export-import">7. Option B – Export then Import (file-based)</h2>
  <p>Use this when you cannot run both instances at once, or you want a backup file to copy to another machine (or to Strapi Cloud).</p>

  <h3>7.1 Export on the source machine</h3>
  <ol>
    <li>On the <strong>source</strong> machine, in the project root, run one of the following.</li>
    <li><strong>Default (encrypted + compressed)</strong> – you will be prompted for an encryption key, or pass it with <code>-k</code>:
      <pre><code>npm run strapi export -- -f my-export
# Or with key (store this key securely; you need it for import):
npm run strapi export -- -f my-export -k "your-secure-encryption-key"</code></pre>
      This creates <code>my-export.tar.gz.enc</code> in the project root.
    </li>
    <li><strong>Without encryption</strong> (easier for local copy, less secure):
      <pre><code>npm run strapi export -- --no-encrypt -f my-export</code></pre>
      Creates <code>my-export.tar.gz</code>.
    </li>
    <li><strong>Plain tar</strong> (no compression, no encryption) – useful to inspect or edit before import:
      <pre><code>npm run strapi export -- --no-encrypt --no-compress -f my-export</code></pre>
      Creates <code>my-export.tar</code>. You can extract it and inspect <code>configuration/</code>, <code>entities/</code>, <code>links/</code>, <code>schemas/</code>, <code>metadata.json</code>.
    </li>
  </ol>
  <p>Then <strong>copy the export file</strong> to the destination machine (or to Strapi Cloud if you use import there – see Strapi Cloud docs).</p>

  <h3>7.2 Import on the destination machine</h3>
  <ol>
    <li>On the <strong>destination</strong>, use the <strong>same project code</strong> (same schema). Place the export file in the project root or note its path.</li>
    <li>Run (on Windows use a full path in double quotes):
      <pre><code>npm run strapi import -- -f "C:\project_workspace\strapi-editorial-template\my-export.tar.gz"</code></pre>
      If the file is encrypted, you will be prompted for the key, or pass it:
      <pre><code>npm run strapi import -- -f "C:\project_workspace\strapi-editorial-template\my-export.tar.gz.enc" -k "your-secure-encryption-key"</code></pre>
    </li>
    <li>For non-interactive use: <code>--force</code> (and <code>-k</code> for encrypted files):
      <pre><code>npm run strapi import -- -f "C:\project_workspace\strapi-editorial-template\my-export.tar.gz.enc" -k "your-secure-encryption-key" --force</code></pre>
    </li>
    <li><strong>Windows – full command (plain .tar, non-interactive):</strong>
      <pre><code>npm run strapi import -- -f "E:\project_workspace\strapi-editorial-template\my-export-1.tar" --force</code></pre>
      Replace the path with your export file location. For encrypted files, add <code>-k "your-encryption-key"</code> before <code>--force</code>.
    </li>
    <li>Confirm when asked: the import <strong>deletes all existing data</strong> (database and uploads) before importing.</li>
  </ol>
  <div class="caution">
    Import <strong>replaces</strong> the destination database and uploads. Admin users are not in the export; recreate them on the destination after import.
  </div>

  <h3>7.2.1 Preserving publishedAt dates (Editorial Articles / news)</h3>
  <p>Strapi import can reset <code>publishedAt</code> to the import date instead of keeping the original publication date from the source. To restore the correct dates for articles/news <strong>after import</strong>:</p>
  <ol>
    <li>Stop Strapi on the destination machine.</li>
    <li>Run the restore script, passing the path to the export file:
      <pre><code>npm run restore:article_dates_from_export -- "E:\project_workspace\strapi-editorial-template\my-export-1.tar"</code></pre>
      Or set the path via environment variable:
      <pre><code>EXPORT_TAR=my-export-1.tar npm run restore:article_dates_from_export</code></pre>
    </li>
    <li>Restart Strapi. Editorial Articles (news) should now show the original <code>publishedAt</code> dates.</li>
  </ol>
  <p>The script reads <code>entities/*.jsonl</code> from the export file and updates the <code>articles</code> table for any Editorial Article (news) whose <code>publishedAt</code> differs from the export. Articles/news are matched by <code>documentId</code> or <code>slug</code>.</p>

  <h2>7.3 Import performance – why it is slow and how to speed it up</h2>
  <p><code>strapi import</code> is often very slow for large exports (especially those with many assets). A 373 MB export can take <strong>several hours</strong> instead of minutes.</p>

  <h3>Why import is slow</h3>
  <ul>
    <li><strong>Known issue</strong> – Reported import speeds of ~20–45 KB/s even for local, unencrypted files.</li>
    <li><strong>Asset bottleneck</strong> – The import processes each asset file by repeatedly scanning the archive for matching metadata (O(n²) behavior). With thousands of images, this becomes extremely slow.</li>
    <li><strong>SQLite</strong> – Writes and indexing add overhead, but the main bottleneck is the import implementation, not the database.</li>
  </ul>

  <h3>What helps today</h3>
  <table>
    <thead>
      <tr><th>Action</th><th>Effect</th></tr>
    </thead>
    <tbody>
      <tr><td>Use plain <code>.tar</code> (no compression)</td><td>Faster than <code>.tar.gz</code>; skip decompression during import.</td></tr>
      <tr><td>Avoid encryption</td><td>Export with <code>--no-encrypt</code>; decryption adds overhead.</td></tr>
      <tr><td>Try <strong>Transfer</strong> instead</td><td>Stream directly between running instances; may be faster in some setups.</td></tr>
      <tr><td>Manual copy (advanced)</td><td>Copy the SQLite DB file and <code>public/uploads</code> folder; faster but only when schemas match exactly.</td></tr>
    </tbody>
  </table>

  <h3>Strapi Cloud and database change</h3>
  <ul>
    <li><strong>Strapi Cloud</strong> uses PostgreSQL. Import speed is still limited by the same bottleneck; expect similar runtimes until the fix is merged.</li>
    <li><strong>Switching to PostgreSQL</strong> locally can improve general DB performance but does <strong>not</strong> fix the slow asset import. The bottleneck is in the import logic, not the database.</li>
  </ul>

  <h3>PR #25268 – “fix: implement asset metadata cache”</h3>
  <p>An open community PR addresses the main cause of slow imports by caching asset metadata up front (O(n) instead of O(n²)).</p>
  <ul>
    <li><strong>PR:</strong> <a href="https://github.com/strapi/strapi/pull/25268" target="_blank" rel="noopener">https://github.com/strapi/strapi/pull/25268</a></li>
    <li><strong>Result for one user:</strong> ~25k assets (~3 GB): 18 KB/s → ~118 MB/s; import time from hours to ~27 seconds.</li>
    <li><strong>Status:</strong> Open (as of early 2026); not yet merged into Strapi.</li>
  </ul>

  <h3>Applying PR #25268 locally (advanced)</h3>
  <p>If you are comfortable building from source, you can apply the PR to your Strapi installation. This requires Node.js, Yarn, and Git.</p>
  <ol>
    <li><strong>Clone the Strapi monorepo</strong> (use a sibling directory to your project):
      <pre><code>cd E:\project_workspace
git clone https://github.com/strapi/strapi.git strapi-source
cd strapi-source</code></pre>
    </li>
    <li><strong>Fetch and checkout the PR branch</strong>:
      <pre><code>git fetch origin pull/25268/head:fix/slow-assets-import
git checkout fix/slow-assets-import</code></pre>
    </li>
    <li><strong>Install dependencies and build</strong> (this can take several minutes):
      <pre><code>yarn install
yarn build</code></pre>
      If <code>yarn build</code> fails or is slow, try building only the data-transfer package:
      <pre><code>cd packages/core/data-transfer
yarn build
cd ../../..</code></pre>
    </li>
    <li><strong>Link the patched package into your Strapi project</strong>:
      <pre><code>cd packages/core/data-transfer
yarn link
cd E:\project_workspace\strapi-editorial-template
yarn link @strapi/data-transfer</code></pre>
    </li>
    <li><strong>Run the import</strong> in your project:
      <pre><code>npm run strapi import -- -f "E:\project_workspace\strapi-editorial-template\my-export-1.tar" --force</code></pre>
    </li>
  </ol>
  <div class="warn">
    <strong>Caveats:</strong> The linked package may not match your Strapi version exactly. If you see errors, revert with <code class="code-highlight">yarn unlink @strapi/data-transfer</code> and <code class="code-highlight">yarn install</code>. Re-apply the link after every <code class="code-highlight">npm install</code> or <code class="code-highlight">yarn install</code> in your project. Check the PR page for updates and whether it has been merged.
  </div>

  <h3>7.3.1 KnexTimeoutError during import (SQLite)</h3>
  <p>During long imports (many assets), you may see:</p>
  <pre><code>KnexTimeoutError: Knex: Timeout acquiring a connection. The pool is probably full.
at ... weekly-metrics.js</code></pre>
  <p>This happens when the upload plugin’s scheduled metrics job tries to use the database while the import is holding the SQLite connection. SQLite allows only one writer at a time.</p>
  <p><strong>Workaround:</strong> Before running import, set a higher connection timeout in <code>.env</code>:</p>
  <pre><code>DATABASE_CONNECTION_TIMEOUT=600000</code></pre>
  <p>This sets 10 minutes (600000 ms). For very large imports, you can use <code>900000</code> (15 min) or <code>1800000</code> (30 min). The metrics job will wait longer before timing out; if the import finishes or briefly releases the connection, the job may succeed.</p>
  <p><strong>Better fix:</strong> Apply <a href="https://github.com/strapi/strapi/pull/25268" target="_blank" rel="noopener">PR #25268</a> (see §7.3) to speed up asset import (hours → minutes), which reduces the window for this error. Alternatively, use PostgreSQL instead of SQLite for large datasets; it handles concurrent connections better.</p>

  <h2 id="included">8. What is included / excluded</h2>
  <table>
    <thead>
      <tr><th>Data</th><th>Transfer</th><th>Export/Import</th></tr>
    </thead>
    <tbody>
      <tr><td>Content (entities, relations)</td><td>Yes</td><td>Yes</td></tr>
      <tr><td>Uploaded files (media)</td><td>Yes</td><td>Yes (if stored locally; not from 3rd party providers like S3/Cloudinary)</td></tr>
      <tr><td>Project configuration</td><td>Yes</td><td>Yes</td></tr>
      <tr><td>Schemas</td><td>Yes (must match)</td><td>Yes (must match)</td></tr>
      <tr><td>Admin users</td><td>No</td><td>No</td></tr>
      <tr><td>API tokens</td><td>No</td><td>No</td></tr>
      <tr><td>createdBy / updatedBy</td><td>N/A</td><td>Empty after import</td></tr>
    </tbody>
  </table>

  <h2 id="cloud">9. Strapi Cloud</h2>
  <p>You can run the same Strapi project on Strapi Cloud and optionally move your data there.</p>

  <h3>9.1 Deploy the project to Strapi Cloud (first time)</h3>
  <ol>
    <li>Prerequisites: Google, GitHub, or GitLab account; local Strapi project <strong>under 100MB</strong>.</li>
    <li>In the project root:
      <pre><code>npx strapi login</code></pre>
      Complete login in the browser (Google/GitHub/GitLab).
    </li>
    <li>Deploy:
      <pre><code>npx strapi deploy</code></pre>
      This creates a new Strapi Cloud project (Free plan) and deploys your code. It may take a few minutes.</li>
    <li>After deploy, the Cloud dashboard will show your project URL (e.g. <code>https://your-project.strapiapp.com</code>). Open the admin at <code>https://your-project.strapiapp.com/admin</code> and create your first admin user.</li>
  </ol>

  <h3>9.2 Import data into Strapi Cloud</h3>
  <p>You have two main options:</p>
  <ul>
    <li><strong>Transfer (recommended)</strong> – From your self-hosted machine, run <code>strapi transfer --to https://your-project.strapiapp.com/admin</code>. Create a <strong>Transfer Token</strong> in the Strapi Cloud admin (Settings → Global settings → Transfer Tokens) with type <strong>Push</strong> or <strong>Full Access</strong>, then use that token when prompted. This streams content, files, and config into Cloud (same schema required).</li>
    <li><strong>Export then Import</strong> – Export from self-hosted (see §7.1); then run <code>strapi import</code> on Cloud if your plan supports it (see §9.2.1).</li>
  </ul>
  <p>After data is in Cloud, recreate admin users (and API tokens) in the Cloud admin as needed.</p>

  <h3>9.2.1 When transfer keeps failing: Export locally, then import on Cloud</h3>
  <p>If transfer repeatedly fails (e.g. 403 on assets, WebSocket closed, or timeouts), use a file-based flow:</p>
  <ol>
    <li><strong>Export on your local machine</strong> (project root):
      <ul>
        <li>With S3 for media: your DB already has file records with full S3 URLs. The export includes <strong>metadata and those URLs</strong>; it does <strong>not</strong> include the actual file bytes (they stay on S3). Export is relatively small and fast.</li>
        <li>With local uploads: the export includes metadata <strong>and</strong> the files from <code>public/uploads</code> (archive can be large).</li>
      </ul>
      <pre><code>npm run strapi export -- --no-encrypt -f my-export</code></pre>
      Or with encryption (you will need the key for import):
      <pre><code>npm run strapi export -- -f my-export -k "your-secure-encryption-key"</code></pre>
      This creates <code>my-export.tar.gz</code> or <code>my-export.tar.gz.enc</code> in the project root. Copy this file somewhere safe (you will upload it to Cloud if import is available).
    </li>
    <li><strong>Import on Strapi Cloud</strong> – As of the current <a href="https://docs.strapi.io/cloud" target="_blank" rel="noopener">Strapi Cloud documentation</a>:
      <ul>
        <li>The <strong>Strapi Cloud CLI</strong> (<code>strapi login</code>, <code>deploy</code>, <code>link</code>, <code>projects</code>, <code>logout</code>) runs on your machine only; it does not provide a shell or “run command” on the Cloud server, so you cannot run <code>strapi import</code> on Cloud via the official CLI.</li>
        <li>The dashboard <strong>“Import data”</strong> (under project Settings → Configuration → Environment data) is for <strong>transferring data between Strapi Cloud environments</strong> (e.g. Production → Staging) on Pro/Scale plans only—not for uploading an export file from self-hosted.</li>
        <li>There is no documented way to upload an export file and run <code>strapi import</code> inside a Strapi Cloud project. The supported path from self-hosted to Cloud is <strong>Transfer</strong> (see §9.2).</li>
      </ul>
      <p><strong>If transfer keeps failing</strong>, use the export above as a local backup, then:</p>
      <ul>
        <li><strong>Retry transfer</strong> when the Cloud app is warm (e.g. after opening the admin), or during off-peak times; Free tier may have limits on outbound/transfer.</li>
        <li><strong>Upgrade plan</strong> (e.g. Pro/Scale) if you need higher limits or different transfer behavior; check <a href="https://strapi.io/pricing-cloud" target="_blank" rel="noopener">Strapi Cloud pricing</a>.</li>
        <li><strong>Contact Strapi support</strong> to ask whether import-from-file is or will be available on Cloud, or for help with transfer 403/timeouts (e.g. <a href="https://support.strapi.io" target="_blank" rel="noopener">support.strapi.io</a>, or via the Cloud dashboard).</li>
      </ul>
    </li>
    <li><strong>After import</strong>: Recreate admin users and API tokens in the Cloud admin. If you use S3 and the export contained only metadata + URLs, ensure the Cloud project is configured to use the same S3 bucket (or that the stored URLs are still reachable); then media will work without re-uploading files.</li>
  </ol>

  <h3>9.3 Link an existing Strapi Cloud project</h3>
  <p>If you already created a project in the Strapi Cloud dashboard and want to link your local repo to it:</p>
  <pre><code>npx strapi link</code></pre>
  <p>Follow the prompts to select the Cloud project. Then you can deploy with <code>npx strapi deploy</code> or use transfer/import as above.</p>

  <h2 id="cloud-troubleshoot">10. Strapi Cloud – Post-transfer troubleshooting</h2>
  <p>This section summarizes what appears in Strapi Cloud logs after a data transfer (push with token), why uploads return 404, and the recommended fix. It ties together bootstrap fixes, media 404s, and S3 feasibility.</p>

  <h3>10.1 What the logs show</h3>
  <p><strong>Bootstrap (addressed in this project):</strong> The following are fixed via <code>src/bootstrap.js</code>:</p>
  <ul>
    <li><strong>Homepage crash</strong> – <code>Cannot read properties of undefined (reading 'settings')</code> in <code>getContentTypesMeta</code>. Fix: <code>ensureContentManagerConfigurations()</code> so every content type has a configuration in core-store (including <code>mainField</code> and <code>settings</code>).</li>
    <li><strong>Bishop list 400</strong> – <code>sort=undefined:undefined</code>. Fix: <code>ensureCollectionTypesHaveDefaultSort()</code> so all API collection types have <code>defaultSortBy</code> and <code>defaultSortOrder</code> (using mainField or documentId as fallback).</li>
  </ul>
  <p><strong>After transfer on Cloud you may still see:</strong></p>
  <ul>
    <li><strong>Upload 404s</strong> – e.g. <code>GET /uploads/mar_chrisostomos_1520bbb7f7.jpeg</code> → 404. File <em>records</em> exist in the database (from the transfer), but the <em>actual files</em> are not on the Cloud server’s filesystem.</li>
    <li><strong>Data transfer behavior</strong> – Strapi Data Transfer (push with token) moves database content and can stream assets; on Strapi Cloud the runtime filesystem is ephemeral or not populated with your local <code>public/uploads</code>, so media files often do not exist where the app serves them → 404.</li>
  </ul>

  <h3>10.1.1 Transfer fails: 403 on assets + “WebSocket is not open: readyState 3 (CLOSED)”</h3>
  <p>If transfer succeeds for <strong>entities</strong> then fails with <code>Request failed with status code 403</code> in the assets phase and <code>WebSocket is not open: readyState 3 (CLOSED)</code>, the 403 is the root cause (the WebSocket closes after the error). This often happens when pushing to Strapi Cloud (e.g. Free tier limits, or the destination rejecting asset streams).</p>
  <p><strong>Fix when your media is already on S3:</strong> Exclude the <strong>files</strong> (asset binaries) from the transfer. Content and file <em>records</em> (with S3 URLs) still transfer; only the binary stream is skipped, so you avoid the 403. Media will work on Cloud if the Cloud project uses the same S3 bucket (see §10.3).</p>
  <p>From your <strong>local</strong> project root (<a href="https://docs.strapi.io/cms/data-management/transfer#exclude-data-types-during-transfer" target="_blank" rel="noopener">Strapi docs – exclude data types</a>):</p>
  <pre><code>npm run strapi transfer -- --to https://YOUR-CLOUD-PROJECT.strapiapp.com/admin --exclude files</code></pre>
  <p>With token in env (non-interactive):</p>
  <pre><code>npm run strapi transfer -- --to https://YOUR-CLOUD-PROJECT.strapiapp.com/admin --to-token YOUR_TRANSFER_TOKEN --exclude files --force</code></pre>
  <p><strong>Note:</strong> Excluding <code>files</code> means existing asset binaries on the <em>destination</em> are deleted by the transfer; your content and upload <em>records</em> (and S3 URLs) are still transferred. If you do <strong>not</strong> use S3 and need binaries on Cloud, you must resolve the 403 (e.g. retry, different plan, or support) instead of excluding files.</p>
  <p>If you use custom <strong>WebSockets or Socket.io</strong> on the same port as Strapi, the <a href="https://docs.strapi.io/cms/data-management/transfer#setup-and-run-the-data-transfer" target="_blank" rel="noopener">data transfer docs</a> require disabling them or moving them to another port/route; otherwise the transfer can fail. This project does not enable custom websockets.</p>

  <h3>10.1.2 Transfer runs a long time then fails: “WebSocket is not open: readyState 3 (CLOSED)” (no 403)</h3>
  <p>If you see <strong>entities transferred</strong> (e.g. 12k+ in ~15–30 min) and then <code>WebSocket is not open: readyState 3 (CLOSED)</code> during or after <strong>links</strong> / <strong>configuration</strong>, with <strong>no 403</strong>, the connection is being closed by timeout or by the server during a long transfer. This is a <a href="https://github.com/strapi/strapi/issues/20304" target="_blank" rel="noopener">known Strapi issue</a> (see also <a href="https://github.com/strapi/strapi/issues/17749" target="_blank" rel="noopener">#17749</a>).</p>
  <p><strong>Try in this order:</strong></p>
  <ol>
    <li><strong>Throttle the transfer</strong> – Slowing chunks can reduce memory pressure and help the WebSocket stay open (<a href="https://docs.strapi.io/cms/data-management/transfer#setup-and-run-the-data-transfer" target="_blank" rel="noopener">docs</a>). Example (add <code>--throttle 200</code> = 200 ms delay between chunks):
      <pre><code>npm run strapi transfer -- --to https://YOUR-CLOUD-PROJECT.strapiapp.com/admin --to-token YOUR_TOKEN --exclude files --throttle 200 --force</code></pre>
      Start with <code>100</code>–<code>500</code> ms; higher values make the transfer longer but may avoid closure.
    </li>
    <li><strong>Keep Cloud warm, then retry</strong> – Open the Cloud admin in a browser and leave it open; run the transfer immediately after. Retry once or twice; sometimes the connection survives.
    </li>
    <li><strong>Run during off-peak</strong> – Try when Cloud or your network is less loaded.
    </li>
    <li><strong>Escalate</strong> – If it still fails, add your case to <a href="https://github.com/strapi/strapi/issues/20304" target="_blank" rel="noopener">GitHub #20304</a> or contact <a href="https://support.strapi.io" target="_blank" rel="noopener">Strapi support</a>; long-transfer WebSocket closure is a platform/CLI limitation. Strapi Cloud does not offer <code>strapi import</code> from a file, so transfer is the only supported path (see §9.2.1).</li>
  </ol>

  <h3>10.1.3 How to know the total size of the transfer (and why it may fail around 6–7 MB)</h3>
  <p><strong>Transfer does not write a single file</strong> – it streams data over WebSocket. You can still measure or estimate the payload size in two ways.</p>
  <p><strong>1. From the transfer log (when you run transfer)</strong></p>
  <p>The CLI prints the size for each phase, for example:</p>
  <pre><code>✖ entities: 12640 transferred (size: 12 MB)
✖ links: 32 transferred (size: 6.1 KB)
✖ configuration: 32 transferred (size: 191 KB)</code></pre>
  <p>Add those numbers to get the <strong>total size</strong> (e.g. ~12.2 MB without assets). If the run fails, you still see the last completed phase size (e.g. entities 12 MB), so you know at least that much was sent before the WebSocket closed.</p>
  <p><strong>2. From an export (same data, gives a file size)</strong></p>
  <p>An export contains the same kind of data as a transfer (entities, links, config; with S3, no file bytes). So the <strong>export file size</strong> is a good approximation of the transfer payload when using <code>--exclude files</code>.</p>
  <ol>
    <li>Run an export (project root):
      <pre><code>npm run strapi export -- --no-encrypt -f transfer-size-check</code></pre>
      This creates <code>transfer-size-check.tar.gz</code> (or use <code>--no-compress</code> for <code>transfer-size-check.tar</code>).
    </li>
    <li>Check the file size (Windows PowerShell):
      <pre><code>(Get-Item .\transfer-size-check.tar.gz).Length / 1MB</code></pre>
      Or in Explorer: right‑click the file → Properties → Size. The size in MB is roughly what gets streamed during transfer (without assets if you use S3 / exclude files). You can also run <code>npm run measure:transfer-size</code> to create this export and print its size in one step.</li>
  </ol>
  <p><strong>Why it might fail after ~6–7 MB (or at another size)</strong></p>
  <p>Strapi does not document a fixed “6 MB limit.” Failures can be:</p>
  <ul>
    <li><strong>Payload / message limit</strong> – A proxy or Strapi Cloud may cap request/WebSocket message size (e.g. 6–10 MB). Once the stream exceeds that, the connection can close.</li>
    <li><strong>Timeout</strong> – The connection may close after a period of time (e.g. 30–60 s) rather than at a specific byte count. Your “6–7 MB” might be how much was sent before the timeout.</li>
    <li><strong>WebSocket / memory</strong> – Long or heavy streams can trigger closure (see <a href="https://github.com/strapi/strapi/issues/17749" target="_blank" rel="noopener">#17749</a>, <a href="https://github.com/strapi/strapi/issues/20304" target="_blank" rel="noopener">#20304</a>).</li>
  </ul>
  <p><strong>How to reduce the size of the transfer</strong></p>
  <ul>
    <li><strong>--exclude files</strong> – Already the biggest win: no asset binaries. Use this when media is on S3 (see §10.1.1).</li>
    <li><strong>Reduce content at source</strong> – Archive or delete old or unused content (e.g. old articles, test data) so the database has fewer/smaller entities. Then run transfer again. Smaller DB ⇒ smaller entities payload.</li>
    <li>There is <strong>no CLI option</strong> to “transfer only first N entities” or “limit to X MB.” The only levers are excluding <code>files</code> and reducing how much content you have.</li>
  </ul>
  <p>If you confirm the total size with the export file and it's still under a few dozen MB but transfer fails, the limit is likely <strong>time or connection stability</strong> rather than size; use <code>--throttle</code> and "keep Cloud warm" (see §10.1.2).</p>

  <h3>10.1.4 Cloud log diagnosis: WebSocket connection cycling and resource contention</h3>
  <p>If you have access to the Strapi Cloud runtime logs (Cloud dashboard → Logs), look for the following pattern that confirms the WebSocket is not sustaining a stable connection:</p>
  <pre><code>[Data transfer] Disabling http timeouts
[Data transfer] Disabling lifecycle hooks
GET /admin/transfer/runner/push (1233 ms) 200
[Data transfer] Restoring http timeouts
[Data transfer] Restoring lifecycle hooks
... (repeats 5+ times in rapid succession)</code></pre>
  <p>Each cycle means the transfer push runner <strong>connects, runs for ~1–2 seconds, then tears down</strong>. The connection is not held open long enough to stream all entities. This pattern typically repeats many times before the WebSocket finally fails permanently.</p>

  <h4>Common contributing factors visible in Cloud logs</h4>
  <table>
    <thead>
      <tr><th>Log pattern</th><th>What it means</th><th>Impact</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>GET /content-manager/homepage/count-documents (5747 ms) 200</code></td>
        <td>Someone is browsing the Cloud admin panel while the transfer is running.</td>
        <td><strong>High.</strong> Admin queries (especially homepage stats and recent-documents) take 5–10 seconds on resource-constrained Cloud instances, starving the WebSocket of CPU/memory.</td>
      </tr>
      <tr>
        <td><code>POST /admin/login (522 ms) 200</code> and content-manager requests interleaved with transfer cycles</td>
        <td>Active admin session competing with the transfer for the same single-process Node.js runtime.</td>
        <td><strong>High.</strong> Strapi runs in a single Node process; heavy admin queries block the event loop and can cause the WebSocket to miss heartbeats → closure.</td>
      </tr>
      <tr>
        <td><code>GET /wordpress/ (5 ms) 404</code>, <code>POST / (2 ms) 405</code></td>
        <td>External bot/scanner probes hitting the Cloud URL.</td>
        <td><strong>Low.</strong> Fast 404/405 responses; negligible impact but adds noise.</td>
      </tr>
      <tr>
        <td>All transfer runner responses taking 1200–1700 ms</td>
        <td>The Cloud instance is slow to respond; each WebSocket handshake costs over a second.</td>
        <td><strong>Medium.</strong> Indicates a resource-constrained instance (free or starter tier). Each reconnection attempt wastes time.</td>
      </tr>
    </tbody>
  </table>

  <h4>Remediation checklist (before retrying transfer)</h4>
  <ol>
    <li><strong>Close all browser tabs</strong> pointing to the Cloud admin (<code>https://YOUR-PROJECT.strapiapp.com/admin</code>). Do not browse the admin during the transfer.</li>
    <li><strong>Remove or reduce <code>--throttle</code></strong> – With <code>--throttle 500</code> (500 ms delay per chunk), the transfer takes far longer and is more likely to hit a timeout. If the problem is connection duration (not memory), use <strong>no throttle</strong> or <code>--throttle 50</code> so the transfer finishes before the connection is cycled:
      <pre><code>npm run strapi transfer -- --to https://YOUR-CLOUD-PROJECT.strapiapp.com/admin --to-token YOUR_TOKEN --exclude files --force</code></pre>
    </li>
    <li><strong>Retry immediately after a fresh deploy</strong> – The Cloud instance is "warmest" right after deploy or after the admin loads once. Run the transfer within a minute of that.</li>
    <li><strong>Check your Cloud plan</strong> – Free/starter tiers have lower resource limits (CPU, memory, request duration). If possible, temporarily upgrade during the migration.</li>
  </ol>

  <h3>10.1.5 Alternative: batched REST API push (bypasses WebSocket entirely)</h3>
  <p>If <code>strapi transfer</code> consistently fails due to WebSocket instability on Strapi Cloud (see §10.1.2 and §10.1.4), you can bypass the WebSocket-based transfer protocol entirely and push content via the <strong>Strapi Content API (REST)</strong>. This approach is more resilient because each request is independent — a failure in one batch does not lose progress from previous batches.</p>

  <h4>How it works</h4>
  <ol>
    <li><strong>Export</strong> your local data to a file (<code>strapi export --no-encrypt -f my-export</code>).</li>
    <li>A script reads the export archive (tar.gz), extracts entities and links by content type.</li>
    <li>For each content type, the script sends <strong>small batches</strong> (e.g. 10–50 entries) to the Cloud instance via <code>POST /api/&lt;content-type&gt;</code> or the bulk endpoint.</li>
    <li>Each batch is an independent HTTP request with its own retry logic. If one batch fails, the script retries it (with backoff) without losing previous batches.</li>
    <li>Relations/links are restored in a second pass after all entities exist on the destination.</li>
  </ol>

  <h4>Advantages over <code>strapi transfer</code></h4>
  <table>
    <thead>
      <tr><th>Aspect</th><th><code>strapi transfer</code> (WebSocket)</th><th>Batched REST API push</th></tr>
    </thead>
    <tbody>
      <tr>
        <td>Connection</td>
        <td>Single long-lived WebSocket — if it drops, <strong>all progress is lost</strong>.</td>
        <td>Many short HTTP requests — each batch is independent; progress is preserved.</td>
      </tr>
      <tr>
        <td>Retry</td>
        <td>No built-in retry; must restart the entire transfer from scratch.</td>
        <td>Per-batch retry with exponential backoff; can resume from where it stopped.</td>
      </tr>
      <tr>
        <td>Proxy / timeout compatibility</td>
        <td>WebSocket upgrades can be blocked or timed out by Cloud proxies and load balancers.</td>
        <td>Standard HTTPS POST; works with any proxy, CDN, or load balancer.</td>
      </tr>
      <tr>
        <td>Observability</td>
        <td>Opaque stream; you see entity counts but cannot inspect or skip individual items.</td>
        <td>Per-batch logging; you can see exactly which content types and entries succeeded or failed.</td>
      </tr>
      <tr>
        <td>Cloud compatibility</td>
        <td>Known issues on free/starter tiers (§10.1.2, §10.1.4).</td>
        <td>Uses the same REST API that the admin panel uses; no special protocol needed.</td>
      </tr>
    </tbody>
  </table>

  <h4>Prerequisites</h4>
  <ul>
    <li><strong>API token on Cloud</strong> – Create a <strong>Full Access</strong> API token in the Cloud admin (Settings → API Tokens → Create new). This is a regular API token (not a transfer token). The token must have permissions to create/update all content types you want to push.</li>
    <li><strong>Schemas must match</strong> – The Cloud instance must have the same content-type schemas as your local project (deploy your code to Cloud first).</li>
    <li><strong>Export file</strong> – Run <code>npm run strapi export -- --no-encrypt -f my-export</code> locally to create the archive.</li>
  </ul>

  <h4>Run the script</h4>
  <p>From the project root, create an export and push it to Cloud:</p>
  <ol>
    <li>Create an export (if you don’t have one):
      <pre><code>npm run strapi export -- --no-encrypt -f my-export</code></pre>
      This creates <code>my-export.tar.gz</code> in the project root.
    </li>
    <li>Set environment variables and run the push script:
      <pre><code>set STRAPI_CLOUD_URL=https://YOUR-PROJECT.strapiapp.com
set STRAPI_CLOUD_API_TOKEN=your-full-access-api-token
node scripts/rest_api_push_to_cloud.js my-export.tar.gz</code></pre>
      Or with npm (pass the export file as an argument):
      <pre><code>set STRAPI_CLOUD_URL=https://YOUR-PROJECT.strapiapp.com
set STRAPI_CLOUD_API_TOKEN=your-full-access-api-token
npm run push:rest-to-cloud -- my-export.tar.gz</code></pre>
      On Linux/macOS use <code>export STRAPI_CLOUD_URL=...</code> instead of <code>set</code>.
    </li>
    <li>Optional env: <code>REST_PUSH_BATCH_SIZE=20</code>, <code>REST_PUSH_RETRY_LIMIT=3</code>, <code>REST_PUSH_DELAY_MS=100</code> (delay between requests to avoid rate limits), <code>REST_PUSH_DRY_RUN=1</code> to only parse the export and log without sending requests. <code>REST_PUSH_INCLUDE_UPLOADS=0</code> skips Phase 0 (no media push; cover will stay empty).</li>
  </ol>
  <p>The script (1) reads the export archive; (2) <strong>Phase 0</strong> – if <code>REST_PUSH_INCLUDE_UPLOADS</code> is not 0, parses <code>plugin::upload.file</code> entities from the export (their <code>data.url</code> are already S3 URLs if you use S3), fetches each file from that URL and POSTs to Cloud <code>/api/upload</code>, and stores ref→documentId so cover can be linked in phase 2; (3) pushes single types then collection types in <strong>dependency order</strong> (“basics first”: tenants, editor-tenants, categories, authors, dioceses, etc., then articles/bishops) so relations and tenant assignment can be resolved; (4) restores relations and media links (PUT with <code>connect</code>). Before creating an entry with a slug, the script checks for an existing document with the same slug (case-insensitive); if found, it reuses that document so duplicate categories (e.g. “Featured News” / “featured news”) are avoided. Content types are taken from your local <code>src/api/*/content-types/*/schema.json</code>.</p>

  <div class="warn">
    <strong>Limitations:</strong>
    <ul>
      <li>The Content API does <strong>not</strong> transfer admin users, API tokens, or permissions — same as <code>strapi transfer</code>.</li>
      <li><strong>Upload (media) files:</strong> The script can push them via <strong>Phase 0</strong> (default on): it reads <code>plugin::upload.file</code> from the export (with S3 <code>data.url</code>), fetches each file from that URL and POSTs to Cloud <code>/api/upload</code>, then phase 2 connects <code>cover</code> and other media fields. Set <code>REST_PUSH_INCLUDE_UPLOADS=0</code> to skip. If Cloud uses the same S3 bucket, Phase 0 still re-uploads (Cloud may store a new key); media will work.</li>
      <li>Relations inside <strong>dynamic zones</strong> or <strong>polymorphic</strong> relations may need extra handling; the script restores top-level relation fields in a second pass.</li>
      <li><code>createdAt</code>, <code>updatedAt</code>, and <code>publishedAt</code> timestamps may not be preserved unless the API accepts them (Strapi 5 often ignores these on create).</li>
      <li>If the Cloud database already has partial data from a failed <code>strapi transfer</code>, <strong>clear it first</strong> (e.g. reset the environment in the Cloud dashboard or redeploy) to avoid duplicate or conflicting entries.</li>
    </ul>
  </div>

  <h4>When to use this approach</h4>
  <ul>
    <li><code>strapi transfer</code> has failed multiple times with WebSocket closure (§10.1.2) despite trying throttle, warm-up, and off-peak timing.</li>
    <li>Your dataset is moderate (tens of thousands of entries, tens of MB) — too large for the WebSocket to survive but well within REST API capacity.</li>
    <li>You are on a Strapi Cloud free or starter tier where WebSocket stability is limited.</li>
    <li>You want <strong>resumable, observable progress</strong> rather than an all-or-nothing stream.</li>
  </ul>

  <h4>Why category, tenant, author, or cover (image) are empty after push</h4>
  <p>If articles (or other entries) appear on Cloud but <strong>relations</strong> (category, tenant, author) or <strong>cover</strong> (image) are empty:</p>
  <ul>
    <li><strong>Relations</strong> – The script restores them in phase 2 (PATCH with <code>connect</code>). If category/author/tenant failed to create in phase 1 (e.g. 405, or duplicate slug and lookup failed), their documentIds are missing from the map, so phase 2 cannot link them. The script now pushes <strong>dependency types first</strong> (tenants, categories, authors, dioceses, etc.) so their documentIds are in the map before articles; if you had run an older run without that order, relations could be empty.</li>
    <li><strong>Cover (image)</strong> – By default the script now runs <strong>Phase 0</strong>: it reads <code>plugin::upload.file</code> entities from the export (which already contain <strong>S3 URLs</strong> if you migrated to S3). For each file it fetches from that URL and POSTs to the Cloud <code>/api/upload</code> endpoint, then maps the old ref to the new documentId so phase 2 can connect <code>cover</code>. So <strong>cover is linked automatically</strong> when you run <code>npm run push:rest-to-cloud</code>. Set <code>REST_PUSH_INCLUDE_UPLOADS=0</code> to skip uploads (cover will stay empty). If Phase 0 fails with <strong>403</strong> when fetching from S3, the bucket may be private — ensure the bucket allows GetObject (bucket policy or public read); the ACL fix in <code>config/env</code> only affects Strapi’s upload to S3, not the script’s fetch.</li>
    <li><strong>Phase 2 warnings:</strong> If you see <code>[Phase 2] … target(s) not in map</code>, the script could not link that relation because the target entry was not created or not in the documentId map (e.g. tenant/category failed in phase 1 or was skipped). Clear Cloud data and re-run push with dependency order to fix.</li>
  </ul>
  <p><strong>Start fresh:</strong> Clear all collection data on Cloud, then re-run the push so relations are applied correctly (dependency order + phase 2). Use the clear script (same env as push):</p>
  <pre><code>set STRAPI_CLOUD_URL=https://YOUR-PROJECT.strapiapp.com
set STRAPI_CLOUD_API_TOKEN=your-token
npm run clear:cloud-data</code></pre>
  <p>Then run <code>npm run push:rest-to-cloud -- your-export.tar.gz</code> again. Optionally use <code>--dry-run</code> with the clear script to only list what would be deleted.</p>

  <h3 id="rest-push-summary">10.1.6 REST push – summary and helper scripts</h3>
  <p>This subsection summarizes the REST API push flow, upload behavior, relation handling, and the helper scripts used with it.</p>

  <h4>What the REST push script does</h4>
  <ul>
    <li><strong>Reads the export</strong> – Parses <code>entities/</code> and <code>links/</code> from the Strapi export archive (tar.gz). Entity refs are indexed by both <code>documentId</code> (string) and numeric <code>id</code> so relation links (which may use numeric ids) match correctly.</li>
    <li><strong>Phase 0 (uploads)</strong> – Only uploads media that are <strong>referenced</strong> by entities (e.g. <code>cover</code>, <code>image</code>). Unreferenced and demo/sample files (e.g. <code>daviddoe@strapi</code>, <code>coffee-art</code>) are skipped to avoid thousands of unnecessary uploads and 403 errors. If <code>REST_PUSH_INCLUDE_UPLOADS=0</code>, Phase 0 is skipped entirely.</li>
    <li><strong>Phase 1 (content)</strong> – Pushes single types then collection types in dependency order (tenants, categories, authors, dioceses, parishes, then articles, bishops, priests, etc.). Each batch is an independent HTTP request with retry. <code>docIdMap</code> stores both export <code>ref</code> and numeric <code>id</code> → new Cloud <code>documentId</code> so Phase 2 can resolve relations.</li>
    <li><strong>Phase 2 (relations)</strong> – Restores category, tenant, author, cover, diocese, and other relation fields via PUT with <code>connect</code>. Relation data comes from the export’s <code>links/</code> (and any relations embedded in entity rows); links are merged into entity meta so patches run for all entities that have relations.</li>
  </ul>

  <h4>Helper scripts (same env: <code>STRAPI_CLOUD_URL</code>, <code>STRAPI_CLOUD_API_TOKEN</code>)</h4>
  <table>
    <thead>
      <tr><th>Script</th><th>Command</th><th>Purpose</th></tr>
    </thead>
    <tbody>
      <tr>
        <td>Clear data (remote or local)</td>
        <td><code>npm run clear:cloud-data</code> or <code>npm run clear:cloud-data -- --local</code></td>
        <td>Deletes all collection-type documents. Default: <strong>remote</strong> (STRAPI_CLOUD_URL). Use <code>--local</code> for local Strapi (STRAPI_LOCAL_URL, STRAPI_LOCAL_API_TOKEN). Options: <code>--types=articles,parishes</code>, <code>--dry-run</code>.</td>
      </tr>
      <tr>
        <td>Keep five per type (remote or local)</td>
        <td><code>npm run cloud:keep-five</code> or <code>npm run cloud:keep-five -- --local</code></td>
        <td>Keeps only 5 records per type for parishes, dioceses, bishops, priests, articles; deletes the rest. Default: <strong>remote</strong>. Use <code>--local</code> for local. Option: <code>--dry-run</code>.</td>
      </tr>
      <tr>
        <td>REST push</td>
        <td><code>npm run push:rest-to-cloud -- my-export.tar.gz</code></td>
        <td>Pushes export content to Cloud via the Content API (phases 0–2 above). Env: <code>REST_PUSH_INCLUDE_UPLOADS=1</code> (default) or <code>0</code> to skip media.</td>
      </tr>
    </tbody>
  </table>

  <h4>Typical order of operations</h4>
  <ol>
    <li>Optional: <code>npm run cloud:keep-five</code> or <code>npm run cloud:keep-five -- --local</code> to keep only 5 records per type (parish, diocese, bishops, priests, articles) on remote or local.</li>
    <li>Optional: <code>npm run clear:cloud-data</code> or <code>npm run clear:cloud-data -- --local</code> to remove all collection data before a full re-push (remote or local).</li>
    <li><code>npm run push:rest-to-cloud -- my-export-3-prod.tar.gz</code> (or your export filename).</li>
  </ol>
  <p><strong>Target:</strong> With no flag (or <code>--remote</code>), scripts use <code>STRAPI_CLOUD_URL</code> and <code>STRAPI_CLOUD_API_TOKEN</code>. With <code>--local</code>, they use <code>STRAPI_LOCAL_URL</code> (default <code>http://localhost:1337</code>) and <code>STRAPI_LOCAL_API_TOKEN</code> (create a Full Access API token in local admin → Settings → API Tokens).</p>

  <h4>Env and behavior summary</h4>
  <ul>
    <li><code>REST_PUSH_INCLUDE_UPLOADS=1</code> (default) – Phase 0 runs; only <strong>referenced</strong> media (cover/image) are uploaded; demo/sample filenames are skipped to avoid 403s.</li>
    <li><code>REST_PUSH_INCLUDE_UPLOADS=0</code> – Phase 0 skipped; no media upload; cover/image relations stay empty.</li>
    <li><code>publishedAt</code> is not stripped from the payload; if the export has it, it is sent (Cloud/API may still override on create).</li>
    <li>If you see “0 links matched” in the log, the export’s <code>links/</code> use a different ref format; the script supports both <code>documentId</code> and numeric <code>id</code> for link left/right.</li>
  </ul>

  <h3>10.2 Why images 404 after push/import to Strapi Cloud</h3>
  <p>Transfer creates or updates <strong>media entries</strong> in the database (admin shows files and URLs). The <strong>binary files</strong> either are not included in what gets deployed to Cloud, or are stored in a different/transient filesystem that does not match the app’s <code>/uploads</code> serving. So when the app or admin requests <code>/uploads/...</code>, the file is not there → <strong>404</strong>.</p>

  <h3>10.3 Best fix for 404s: external object storage (e.g. S3)</h3>
  <p>Use <strong>one external object store</strong> (e.g. S3 or S3-compatible) and point <strong>both</strong> local and Strapi Cloud to it. Then:</p>
  <ul>
    <li>Media lives in one place; no dependency on Cloud’s local disk.</li>
    <li>Transfer only moves DB; URLs already point to the same bucket → no 404s for those assets.</li>
    <li>Uploads from local or Cloud both read/write the same files.</li>
  </ul>
  <p><strong>Do you need S3 on both local and remote?</strong> Yes – configure the <strong>same</strong> bucket in both environments. Local can use the provider so uploads go to the bucket (optional for dev; you can keep local disk for dev only). Strapi Cloud <strong>must</strong> use the provider so it serves from the bucket and does not rely on its own filesystem for uploads. One bucket, two configs (local + Cloud) pointing to that bucket is the standard setup.</p>
  <p><strong>Feasibility:</strong> Straightforward. Add the Strapi upload provider (e.g. S3), set env vars (key, secret, bucket, region, endpoint if needed), and redeploy. New uploads go to S3; for existing records you either re-upload those files or do a one-time copy of <code>public/uploads</code> into the bucket and keep URLs consistent. See <a href="STRAPI_MEDIA_STORAGE_S3_CLOUD_PRD.html">STRAPI_MEDIA_STORAGE_S3_CLOUD_PRD.html</a> for full S3/Cloud refactoring.</p>

  <h3>10.4 Alternatives to S3 (and efficiency)</h3>
  <ul>
    <li><strong>Cloudinary / other image APIs</strong> – Same idea: one external store, configure on both envs. Often more “image-centric” (transformations, CDN). Efficiency is good; cost and API differ from S3.</li>
    <li><strong>Store “a lot of images” in the database (BLOBs)</strong> – Not recommended. Strapi does not ship with “store file bytes in DB” as the default; you would be fighting the design, hurting DB size and backups, and still not solving the “Cloud has no files” problem. Least efficient and not the right tool.</li>
    <li><strong>Manual copy of <code>public/uploads</code> to Cloud</strong> – Theoretically possible (e.g. copy into Cloud’s filesystem or a volume), but Strapi Cloud’s runtime is often ephemeral, so this is fragile and not the intended pattern. Not recommended as the long-term fix.</li>
    <li><strong>S3 (or S3-compatible, e.g. R2, MinIO)</strong> – Most efficient and robust for “lots of images” and transfer workflow: one bucket, CDN optional, no DB bloat, works the same locally and on Cloud.</li>
  </ul>

  <h3>10.5 Quick reference: your questions answered</h3>
  <table>
    <thead>
      <tr><th>Question</th><th>Answer</th></tr>
    </thead>
    <tbody>
      <tr><td>Why 404 when we upload/import data to Strapi Cloud?</td><td>Transfer updates the DB (media entries); the actual files are not on Cloud’s disk, so <code>/uploads/...</code> 404.</td></tr>
      <tr><td>Best fix?</td><td>Use one external object store (e.g. S3) and configure Strapi to use it <strong>on Cloud</strong> (and ideally locally too).</td></tr>
      <tr><td>S3 feasible?</td><td>Yes. One bucket, env-based config; add provider and redeploy.</td></tr>
      <tr><td>S3 on both local and remote?</td><td>Yes – configure the <strong>same</strong> bucket in both environments so both use the same media store.</td></tr>
      <tr><td>Better way without S3?</td><td>Another provider (e.g. Cloudinary) is fine; “store in DB” is not efficient or recommended.</td></tr>
      <tr><td>Most efficient way for lots of images?</td><td>External object storage (S3 or S3-compatible) with one bucket for both envs; optional CDN in front.</td></tr>
    </tbody>
  </table>

  <h3>10.6 Bootstrap vs media</h3>
  <p><strong>Bootstrap</strong> fixes the homepage and bishop list errors; once that version is deployed to Cloud, those issues should stop. <strong>Media 404s</strong> are independent of bootstrap. They are fixed by <strong>where files are stored</strong> (external storage + same URLs), not by bootstrap. So: deploy the fixed bootstrap for admin/list behavior; add S3 (or equivalent) for media so transfer no longer leaves you with missing files and 404s.</p>

  <h2 id="quickref">11. Quick reference</h2>
  <table>
    <thead>
      <tr><th>Goal</th><th>Command / step</th></tr>
    </thead>
    <tbody>
      <tr><td>Push data to another server</td><td>On source: <code>npm run strapi transfer -- --to https://destination/admin</code> (use destination’s transfer token)</td></tr>
      <tr><td>Pull data from another server</td><td>On destination: <code>npm run strapi transfer -- --from https://source/admin</code> (use source’s transfer token)</td></tr>
      <tr><td>Export to file</td><td><code>npm run strapi export -- -f my-export</code> (add <code>-k KEY</code> or <code>--no-encrypt</code> as needed)</td></tr>
      <tr><td>Import from file</td><td><code>npm run strapi import -- -f "C:\…\my-export.tar.gz"</code> (Windows: use full path in quotes; add <code>-k KEY</code>, <code>--force</code> as needed)</td></tr>
      <tr><td>Restore publishedAt after import (articles/news)</td><td><code>npm run restore:article_dates_from_export</code> (set <code>EXPORT_TAR=path\to\export.tar</code> or pass path as arg)</td></tr>
      <tr><td>Avoid KnexTimeoutError during import (SQLite)</td><td>Add <code>DATABASE_CONNECTION_TIMEOUT=600000</code> to <code>.env</code> before import (see §7.3.1)</td></tr>
      <tr><td>Deploy to Strapi Cloud</td><td><code>npx strapi login</code> then <code>npx strapi deploy</code></td></tr>
      <tr><td>Transfer into Strapi Cloud</td><td>Create Push token in Cloud admin; on self-hosted: <code>strapi transfer --to https://your-project.strapiapp.com/admin</code></td></tr>
      <tr><td>REST push to Cloud (bypass WebSocket)</td><td>Set <code>STRAPI_CLOUD_URL</code> and <code>STRAPI_CLOUD_API_TOKEN</code>; then <code>npm run push:rest-to-cloud -- my-export.tar.gz</code> (see §10.1.5 and §10.1.6)</td></tr>
      <tr><td>Clear collection data (remote or local)</td><td><code>npm run clear:cloud-data</code> (remote) or <code>npm run clear:cloud-data -- --local</code> (local). Optional: <code>--dry-run</code>, <code>--types=articles,parishes</code></td></tr>
      <tr><td>Keep 5 records per type (remote or local)</td><td><code>npm run cloud:keep-five</code> (remote) or <code>npm run cloud:keep-five -- --local</code> (local). Optional: <code>--dry-run</code></td></tr>
    </tbody>
  </table>

  <h2 id="docs">12. Official documentation</h2>
  <ul>
    <li><a href="https://docs.strapi.io/cms/data-management/transfer" target="_blank" rel="noopener">Data transfer (Strapi 5)</a></li>
    <li><a href="https://docs.strapi.io/cms/data-management/export" target="_blank" rel="noopener">Data export (Strapi 5)</a></li>
    <li><a href="https://docs.strapi.io/cms/data-management/import" target="_blank" rel="noopener">Data import (Strapi 5)</a></li>
    <li><a href="https://docs.strapi.io/cms/features/data-management" target="_blank" rel="noopener">Data Management feature (transfer tokens)</a></li>
    <li><a href="https://docs.strapi.io/cloud/getting-started/deployment-cli" target="_blank" rel="noopener">Strapi Cloud – Deployment with CLI</a></li>
    <li><a href="https://github.com/strapi/strapi/pull/25268" target="_blank" rel="noopener">PR #25268 – Import performance fix (asset metadata cache)</a></li>
  </ul>

  <script>
    (function() {
      document.querySelectorAll('pre').forEach(function(pre) {
        var wrap = document.createElement('div');
        wrap.className = 'command-wrap';
        var btn = document.createElement('button');
        btn.className = 'copy-btn';
        btn.type = 'button';
        btn.textContent = '📋 Copy';
        btn.title = 'Copy to clipboard';
        btn.setAttribute('aria-label', 'Copy command to clipboard');
        btn.onclick = function() {
          var text = pre.textContent.trim();
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(function() {
              btn.textContent = '✓ Copied!';
              btn.classList.add('copied');
              setTimeout(function() {
                btn.textContent = '📋 Copy';
                btn.classList.remove('copied');
              }, 2000);
            }).catch(function() {
              fallbackCopy(text, btn);
            });
          } else {
            fallbackCopy(text, btn);
          }
        };
        pre.parentNode.insertBefore(wrap, pre);
        wrap.appendChild(btn);
        wrap.appendChild(pre);
      });
      function fallbackCopy(text, btn) {
        var ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.select();
        try {
          document.execCommand('copy');
          btn.textContent = '✓ Copied!';
          btn.classList.add('copied');
          setTimeout(function() {
            btn.textContent = '📋 Copy';
            btn.classList.remove('copied');
          }, 2000);
        } catch (e) {}
        document.body.removeChild(ta);
      }
    })();
  </script>
</body>
</html>
